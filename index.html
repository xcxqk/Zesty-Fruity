<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zesty Fruity - Bullet Hell</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        
        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            width: 480px;
            height: 640px;
            margin: 20px auto;
        }
        
        #gameCanvas {
            background-color: #000;
            display: block;
            border: 2px solid #8a2be2;
            box-shadow: 0 0 20px rgba(138, 43, 230, 0.5);
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
        }
        
        .hidden {
            display: none !important;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            text-align: center;
        }
        
        .title {
            color: #ff66cc;
            font-size: 42px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff66cc;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        .subtitle {
            color: #66ffcc;
            font-size: 18px;
            margin-bottom: 40px;
        }
        
        .button {
            margin: 10px;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            border: none;
            background: none;
            padding: 0;
        }
        
        .button:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 5;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 5px;
        }
        
        .hud div {
            margin-bottom: 5px;
        }
        
        .beta {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ff9966;
            font-size: 12px;
            font-weight: bold;
            z-index: 5;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 3px;
        }
        
        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaa;
            font-size: 12px;
            z-index: 5;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 6px;
            border-radius: 3px;
        }
        
        .lives {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }
        
        .life-icon {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            background-color: #66ffcc;
            border-radius: 50%;
        }
        
        .button-img {
            display: block;
            border: none;
        }
        
        .title-img {
            margin-bottom: 30px;
            max-width: 80%;
        }
        
        #loadingProgress {
            color: #66ffcc;
            font-size: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="480" height="640"></canvas>
        
        <div id="loadingScreen" class="screen">
            <div class="title">Zesty Fruity</div>
            <div class="subtitle">Loading colorful bullet hell...</div>
            <div id="loadingProgress">0%</div>
        </div>
        
        <div id="titleScreen" class="screen hidden">
            <img id="titleImage" class="title-img" alt="Zesty Fruity">
            <button id="startButton" class="button">
                <img id="startBtnImage" class="button-img" alt="START" style="width: 200px; height: 60px;">
            </button>
            <button id="continueButton" class="button hidden">
                <img id="continueBtnImage" class="button-img" alt="CONTINUE" style="width: 200px; height: 60px;">
            </button>
        </div>
        
        <div id="gameOverScreen" class="screen hidden">
            <img id="gameOverImage" class="title-img" alt="GAME OVER" style="max-width: 70%;">
            <div id="finalScore" style="color: #ffcc66; font-size: 24px; margin-bottom: 30px;">Score: 0</div>
            <button id="retryButton" class="button">
                <img id="retryImage" class="button-img" alt="RETRY" style="width: 150px; height: 50px;">
            </button>
            <button id="giveUpButton" class="button">
                <img id="giveUpImage" class="button-img" alt="GIVE UP" style="width: 150px; height: 50px;">
            </button>
        </div>
        
        <div id="hud" class="hud hidden">
            <div>SCORE: <span id="scoreDisplay">0</span></div>
            <div>HIGH: <span id="highScoreDisplay">0</span></div>
            <div>CONTINUES: <span id="continuesDisplay">3</span></div>
            <div class="lives">LIVES: <span id="livesDisplay">3</span></div>
        </div>
        
        <div class="beta">BETA</div>
        
        <div class="controls">
            MOVE: WASD / ARROWS<br>
            SHOOT: SPACE
        </div>
    </div>

    <script>
        // Game constants
        const CANVAS_WIDTH = 480;
        const CANVAS_HEIGHT = 640;
        const PLAYER_SPEED = 4;
        const PLAYER_HITBOX_RADIUS = 4;
        const INITIAL_LIVES = 3;
        const INITIAL_CONTINUES = 3;
        const ENEMY_SPAWN_RATE = 120; // frames between spawns
        const ENEMY2_UNLOCK_SCORE = 5000;
        
        // Game state
        let gameState = 'loading'; // loading, title, playing, gameOver
        let score = 0;
        let highScore = 0;
        let lives = INITIAL_LIVES;
        let continues = INITIAL_CONTINUES;
        let frameCount = 0;
        let difficulty = 1;
        
        // Game objects
        let player = null;
        let enemies = [];
        let playerBullets = [];
        let enemyBullets = [];
        let particles = [];
        let stars = [];
        let clouds = [];
        
        // Input tracking
        const keys = {};
        
        // Canvas context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Image assets - FIXED: Initialize all as null first
        const images = {
            player1: null,
            player2: null,
            playerBullet: null,
            playerBullet2: null,
            enemyBullet: null,
            enemy1: null,
            enemy2: null,
            title: null,
            startBtn: null,
            continueBtn: null,
            gameOver: null,
            retry: null,
            giveUp: null,
            background: null
        };
        
        // Track loaded images
        let imagesLoaded = 0;
        const totalImages = Object.keys(images).length;
        
        // Load high score from localStorage
        function loadHighScore() {
            try {
                const saved = localStorage.getItem('zestyFruityHighScore');
                highScore = saved ? parseInt(saved) : 0;
                if (document.getElementById('highScoreDisplay')) {
                    document.getElementById('highScoreDisplay').textContent = highScore;
                }
            } catch (e) {
                console.log("Could not load high score:", e);
                highScore = 0;
            }
        }
        
        // Save high score to localStorage
        function saveHighScore() {
            try {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('zestyFruityHighScore', highScore.toString());
                }
            } catch (e) {
                console.log("Could not save high score:", e);
            }
        }
        
        // Create placeholder images for missing assets
        function createPlaceholder(color, text = '', width = 32, height = 32) {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                // Draw colored background
                ctx.fillStyle = color;
                
                if (width === height) {
                    // Circle for square images
                    ctx.beginPath();
                    ctx.arc(width/2, height/2, width/2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // Rectangle for non-square images
                    ctx.fillRect(0, 0, width, height);
                    
                    // Draw border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(1, 1, width-2, height-2);
                }
                
                // Draw text if provided
                if (text) {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold ' + Math.min(width/3, 14) + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, width/2, height/2);
                }
                
                return canvas;
            } catch (e) {
                console.log("Error creating placeholder:", e);
                return null;
            }
        }
        
        // Handle image loading
        function handleImageLoad(key, url, placeholderColor, placeholderText, width = 32, height = 32) {
            const img = new Image();
            img.onload = () => {
                images[key] = img;
                imagesLoaded++;
                updateLoadingProgress();
                
                // Update UI images if they exist
                const uiElements = {
                    'title': 'titleImage',
                    'startBtn': 'startBtnImage',
                    'continueBtn': 'continueBtnImage',
                    'gameOver': 'gameOverImage',
                    'retry': 'retryImage',
                    'giveUp': 'giveUpImage'
                };
                
                if (uiElements[key] && document.getElementById(uiElements[key])) {
                    document.getElementById(uiElements[key]).src = img.src;
                }
            };
            
            img.onerror = () => {
                // Use placeholder if image fails to load
                console.log(`Failed to load ${url}, using placeholder`);
                const placeholder = createPlaceholder(placeholderColor, placeholderText, width, height);
                if (placeholder) {
                    images[key] = placeholder;
                }
                imagesLoaded++;
                updateLoadingProgress();
            };
            
            img.src = url;
        }
        
        // Update loading progress
        function updateLoadingProgress() {
            const progress = Math.floor((imagesLoaded / totalImages) * 100);
            const progressElement = document.getElementById('loadingProgress');
            if (progressElement) {
                progressElement.textContent = `${progress}%`;
            }
            
            if (imagesLoaded === totalImages) {
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loadingScreen');
                    if (loadingScreen) {
                        loadingScreen.classList.add('hidden');
                    }
                    showTitleScreen();
                }, 500);
            }
        }
        
        // Load all game assets
        function loadAssets() {
            // Load all images
            handleImageLoad('player1', 'img/player1.png', '#66ffcc', 'P1', 32, 32);
            handleImageLoad('player2', 'img/player2.png', '#ff66cc', 'P2', 32, 32);
            handleImageLoad('playerBullet', 'img/playerBullet.png', '#ffff66', '', 8, 16);
            handleImageLoad('playerBullet2', 'img/playerBullet2.png', '#ff66ff', '', 6, 20);
            handleImageLoad('enemyBullet', 'img/enemyBullet.png', '#ff9966', '', 8, 8);
            handleImageLoad('enemy1', 'img/enemy.png', '#6699ff', 'E1', 40, 40);
            handleImageLoad('enemy2', 'img/enemy2.png', '#9966ff', 'E2', 48, 48);
            handleImageLoad('title', 'img/title.png', '#ff66cc', 'ZESTY FRUITY', 400, 150);
            handleImageLoad('startBtn', 'img/startBtn.png', '#66ff66', 'START', 200, 60);
            handleImageLoad('continueBtn', 'img/continueBtn.png', '#66ccff', 'CONTINUE', 200, 60);
            handleImageLoad('gameOver', 'img/gameOver.png', '#ff6666', 'GAME OVER', 300, 100);
            handleImageLoad('retry', 'img/retry.png', '#66ff66', 'RETRY', 150, 50);
            handleImageLoad('giveUp', 'img/giveUp.png', '#ff9966', 'GIVE UP', 150, 50);
            handleImageLoad('background', 'img/background.png', '#0a0a2a', 'BG', 480, 640);
        }
        
        // Show title screen
        function showTitleScreen() {
            gameState = 'title';
            const titleScreen = document.getElementById('titleScreen');
            const hud = document.getElementById('hud');
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            if (titleScreen) titleScreen.classList.remove('hidden');
            if (hud) hud.classList.add('hidden');
            if (gameOverScreen) gameOverScreen.classList.add('hidden');
            
            // Show continue button if player has continues and has played before
            const continueButton = document.getElementById('continueButton');
            if (continueButton) {
                if (continues > 0 && score > 0) {
                    continueButton.classList.remove('hidden');
                } else {
                    continueButton.classList.add('hidden');
                }
            }
        }
        
        // Show game over screen
        function showGameOverScreen() {
            gameState = 'gameOver';
            const gameOverScreen = document.getElementById('gameOverScreen');
            const hud = document.getElementById('hud');
            const titleScreen = document.getElementById('titleScreen');
            
            if (gameOverScreen) gameOverScreen.classList.remove('hidden');
            if (hud) hud.classList.add('hidden');
            if (titleScreen) titleScreen.classList.add('hidden');
            
            const finalScore = document.getElementById('finalScore');
            if (finalScore) {
                finalScore.textContent = `Score: ${score}`;
            }
        }
        
        // Start a new game
        function startGame(isContinue = false) {
            if (!isContinue) {
                score = 0;
                lives = INITIAL_LIVES;
                continues = INITIAL_CONTINUES;
                difficulty = 1;
            }
            
            // Reset game objects
            player = new Player();
            enemies = [];
            playerBullets = [];
            enemyBullets = [];
            particles = [];
            frameCount = 0;
            
            // Create background stars
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    speed: 0.5 + Math.random() * 2,
                    size: 1 + Math.random() * 3,
                    brightness: 0.3 + Math.random() * 0.7,
                    twinkleSpeed: Math.random() * 0.05,
                    twinkleOffset: Math.random() * Math.PI * 2
                });
            }
            
            // Create clouds for parallax background
            clouds = [];
            for (let i = 0; i < 8; i++) {
                clouds.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    speed: 0.1 + Math.random() * 0.3,
                    size: 30 + Math.random() * 50,
                    opacity: 0.1 + Math.random() * 0.2
                });
            }
            
            // Update UI
            const scoreDisplay = document.getElementById('scoreDisplay');
            const highScoreDisplay = document.getElementById('highScoreDisplay');
            const livesDisplay = document.getElementById('livesDisplay');
            const continuesDisplay = document.getElementById('continuesDisplay');
            
            if (scoreDisplay) scoreDisplay.textContent = score;
            if (highScoreDisplay) highScoreDisplay.textContent = highScore;
            if (livesDisplay) livesDisplay.textContent = lives;
            if (continuesDisplay) continuesDisplay.textContent = continues;
            
            // Show HUD, hide other screens
            const titleScreen = document.getElementById('titleScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const hud = document.getElementById('hud');
            
            if (titleScreen) titleScreen.classList.add('hidden');
            if (gameOverScreen) gameOverScreen.classList.add('hidden');
            if (hud) hud.classList.remove('hidden');
            
            gameState = 'playing';
        }
        
        // Player class
        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT - 80;
                this.width = 32;
                this.height = 32;
                this.speed = PLAYER_SPEED;
                this.shootCooldown = 0;
                this.shootDelay = 8; // frames between shots
                this.isPlayer2 = false; // Start as player 1
                this.invincible = 0; // Invincibility frames after hit
            }
            
            update() {
                // Handle movement input
                let moveX = 0;
                let moveY = 0;
                
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;
                if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;
                if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= 1;
                if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += 1;
                
                // Normalize diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.7071; // 1/sqrt(2)
                    moveY *= 0.7071;
                }
                
                // Update position with bounds checking
                this.x += moveX * this.speed;
                this.y += moveY * this.speed;
                
                // Keep player within canvas bounds
                this.x = Math.max(this.width/2, Math.min(CANVAS_WIDTH - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(CANVAS_HEIGHT - this.height/2, this.y));
                
                // Handle shooting
                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                }
                
                if ((keys[' '] || keys['Spacebar']) && this.shootCooldown === 0) {
                    this.shoot();
                    this.shootCooldown = this.shootDelay;
                }
                
                // Decrease invincibility
                if (this.invincible > 0) {
                    this.invincible--;
                }
                
                // Switch player type at high score
                if (score >= 10000 && !this.isPlayer2) {
                    this.isPlayer2 = true;
                }
            }
            
            shoot() {
                if (this.isPlayer2) {
                    // Player 2 shoots a laser beam
                    playerBullets.push(new PlayerBullet(this.x, this.y - 10, 0, -10, true));
                } else {
                    // Player 1 shoots normal bullets
                    playerBullets.push(new PlayerBullet(this.x - 10, this.y - 10, 0, -8));
                    playerBullets.push(new PlayerBullet(this.x + 10, this.y - 10, 0, -8));
                }
            }
            
            draw() {
                // Draw player sprite (or placeholder)
                const img = this.isPlayer2 ? images.player2 : images.player1;
                
                if (img) {
                    // Flash when invincible
                    if (this.invincible % 4 < 2) {
                        ctx.globalAlpha = 0.7;
                    }
                    
                    ctx.drawImage(img, this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                    ctx.globalAlpha = 1.0;
                } else {
                    // Draw placeholder if no image
                    ctx.fillStyle = this.isPlayer2 ? '#ff66cc' : '#66ffcc';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw hitbox (tiny circle at center)
                ctx.fillStyle = '#ff0000';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(this.x, this.y, PLAYER_HITBOX_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
            
            checkCollision(bullet) {
                if (this.invincible > 0) return false;
                
                const dx = this.x - bullet.x;
                const dy = this.y - bullet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance < (PLAYER_HITBOX_RADIUS + bullet.hitRadius);
            }
        }
        
        // Player bullet class
        class PlayerBullet {
            constructor(x, y, vx, vy, isLaser = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.isLaser = isLaser;
                this.width = isLaser ? 6 : 8;
                this.height = isLaser ? 20 : 16;
                this.hitRadius = isLaser ? 3 : 4;
                this.damage = isLaser ? 2 : 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Remove if off screen
                return this.y > -20 && this.y < CANVAS_HEIGHT + 20 && 
                       this.x > -20 && this.x < CANVAS_WIDTH + 20;
            }
            
            draw() {
                const img = this.isLaser ? images.playerBullet2 : images.playerBullet;
                
                if (img) {
                    ctx.drawImage(img, this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                } else {
                    // Draw colored placeholder
                    ctx.fillStyle = this.isLaser ? '#ff66ff' : '#ffff66';
                    ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                }
            }
        }
        
        // Enemy base class
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 1 or 2
                this.width = type === 1 ? 40 : 48;
                this.height = type === 1 ? 40 : 48;
                this.health = type === 1 ? 5 : 10;
                this.maxHealth = this.health;
                this.speed = type === 1 ? 1 : 0.7;
                this.shootCooldown = Math.floor(Math.random() * 60);
                this.shootDelay = type === 1 ? 90 : 120;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = this.speed;
                this.hitRadius = type === 1 ? 15 : 18;
            }
            
            update() {
                // Move enemy
                this.x += this.vx;
                this.y += this.vy;
                
                // Bounce off walls
                if (this.x < this.width/2 || this.x > CANVAS_WIDTH - this.width/2) {
                    this.vx *= -1;
                }
                
                // Remove if off screen
                if (this.y > CANVAS_HEIGHT + 50) return false;
                
                // Shooting logic
                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else {
                    this.shoot();
                    this.shootCooldown = this.shootDelay / difficulty;
                }
                
                return true;
            }
            
            shoot() {
                const bulletCount = this.type === 1 ? 8 : 12;
                const bulletSpeed = 2 * difficulty;
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (i * (Math.PI * 2) / bulletCount) + (frameCount * 0.02);
                    
                    if (this.type === 2) {
                        // Snowflake pattern for enemy type 2
                        const branchCount = 6;
                        for (let b = 0; b < branchCount; b++) {
                            const branchAngle = angle + (b * Math.PI * 2 / branchCount);
                            enemyBullets.push(new EnemyBullet(
                                this.x, 
                                this.y, 
                                Math.cos(branchAngle) * bulletSpeed,
                                Math.sin(branchAngle) * bulletSpeed
                            ));
                        }
                    } else {
                        // Circular pattern for enemy type 1
                        enemyBullets.push(new EnemyBullet(
                            this.x, 
                            this.y, 
                            Math.cos(angle) * bulletSpeed,
                            Math.sin(angle) * bulletSpeed
                        ));
                    }
                }
            }
            
            draw() {
                const img = this.type === 1 ? images.enemy1 : images.enemy2;
                
                if (img) {
                    ctx.drawImage(img, this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                } else {
                    // Draw colored placeholder
                    ctx.fillStyle = this.type === 1 ? '#6699ff' : '#9966ff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw health bar
                const barWidth = 40;
                const barHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - this.height/2 - 10, barWidth, barHeight);
                ctx.fillStyle = healthPercent > 0.5 ? '#66ff66' : (healthPercent > 0.25 ? '#ffff66' : '#ff6666');
                ctx.fillRect(this.x - barWidth/2, this.y - this.height/2 - 10, barWidth * healthPercent, barHeight);
            }
            
            checkCollision(bullet) {
                const dx = this.x - bullet.x;
                const dy = this.y - bullet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.hitRadius + bullet.hitRadius) {
                    this.health -= bullet.damage;
                    return true;
                }
                return false;
            }
        }
        
        // Enemy bullet class
        class EnemyBullet {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 8;
                this.height = 8;
                this.hitRadius = 6;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Remove if off screen
                return this.y > -20 && this.y < CANVAS_HEIGHT + 20 && 
                       this.x > -20 && this.x < CANVAS_WIDTH + 20;
            }
            
            draw() {
                const img = images.enemyBullet;
                
                if (img) {
                    // Draw with transparency for hitbox visibility
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(img, this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                    ctx.globalAlpha = 1.0;
                } else {
                    // Draw colored placeholder with transparency
                    ctx.fillStyle = 'rgba(255, 153, 102, 0.8)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw hitbox
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Particle effect class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = 2 + Math.random() * 4;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Spawn enemies based on difficulty and score
        function spawnEnemies() {
            // Increase difficulty with score
            difficulty = 1 + Math.min(score / 20000, 3);
            
            // Calculate spawn rate (decreases with difficulty)
            const spawnRate = Math.max(ENEMY_SPAWN_RATE / difficulty, 30);
            
            if (frameCount % Math.floor(spawnRate) === 0) {
                const x = 50 + Math.random() * (CANVAS_WIDTH - 100);
                
                // Spawn enemy type 2 if score is high enough
                if (score >= ENEMY2_UNLOCK_SCORE && Math.random() < 0.3) {
                    enemies.push(new Enemy(x, -40, 2));
                } else {
                    enemies.push(new Enemy(x, -40, 1));
                }
            }
        }
        
        // Update all game objects
        function updateGame() {
            frameCount++;
            
            // Update player
            if (player) {
                player.update();
            }
            
            // Update player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                if (!playerBullets[i].update()) {
                    playerBullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (enemies[j].checkCollision(playerBullets[i])) {
                        // Create hit particles
                        for (let k = 0; k < 5; k++) {
                            particles.push(new Particle(playerBullets[i].x, playerBullets[i].y, '#ffff66'));
                        }
                        
                        playerBullets.splice(i, 1);
                        
                        // Check if enemy is dead
                        if (enemies[j].health <= 0) {
                            // Add score
                            score += enemies[j].type === 1 ? 100 : 300;
                            const scoreDisplay = document.getElementById('scoreDisplay');
                            if (scoreDisplay) scoreDisplay.textContent = score;
                            
                            // Create explosion particles
                            for (let k = 0; k < 15; k++) {
                                particles.push(new Particle(
                                    enemies[j].x, 
                                    enemies[j].y, 
                                    enemies[j].type === 1 ? '#6699ff' : '#9966ff'
                                ));
                            }
                            
                            enemies.splice(j, 1);
                        }
                        
                        break;
                    }
                }
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (!enemies[i].update()) {
                    enemies.splice(i, 1);
                }
            }
            
            // Update enemy bullets and check collision with player
            if (player) {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    if (!enemyBullets[i].update()) {
                        enemyBullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with player
                    if (player.checkCollision(enemyBullets[i])) {
                        // Player hit!
                        enemyBullets.splice(i, 1);
                        
                        // Create hit particles
                        for (let k = 0; k < 10; k++) {
                            particles.push(new Particle(player.x, player.y, '#ff6666'));
                        }
                        
                        // Lose a life
                        lives--;
                        const livesDisplay = document.getElementById('livesDisplay');
                        if (livesDisplay) livesDisplay.textContent = lives;
                        
                        // Make player invincible for a short time
                        player.invincible = 120;
                        
                        // Game over if no lives left
                        if (lives <= 0) {
                            gameOver();
                            return;
                        }
                    }
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                }
            }
            
            // Spawn new enemies
            if (gameState === 'playing') {
                spawnEnemies();
            }
        }
        
        // Draw the background
        function drawBackground() {
            // Draw custom background image if available
            if (images.background && typeof images.background !== 'string') {
                try {
                    // Calculate parallax scrolling
                    const scrollY = (frameCount * 0.5) % CANVAS_HEIGHT;
                    
                    // Draw background twice for seamless scrolling
                    ctx.drawImage(images.background, 0, scrollY - CANVAS_HEIGHT, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.drawImage(images.background, 0, scrollY, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    // Darken the background for better bullet visibility
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                } catch (e) {
                    // Fallback to default background
                    drawDefaultBackground();
                }
            } else {
                drawDefaultBackground();
            }
            
            // Draw stars
            for (const star of stars) {
                // Update star position (scrolling)
                star.y += star.speed * 0.2;
                if (star.y > CANVAS_HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * CANVAS_WIDTH;
                }
                
                // Twinkle effect
                const twinkle = Math.sin(frameCount * star.twinkleSpeed + star.twinkleOffset) * 0.3 + 0.7;
                const brightness = star.brightness * twinkle;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw clouds (parallax background)
            for (const cloud of clouds) {
                cloud.y += cloud.speed * 0.1;
                if (cloud.y > CANVAS_HEIGHT + cloud.size) {
                    cloud.y = -cloud.size;
                    cloud.x = Math.random() * CANVAS_WIDTH;
                }
                
                ctx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity})`;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw default background
        function drawDefaultBackground() {
            // Default gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            gradient.addColorStop(0, '#0a0a2a');
            gradient.addColorStop(0.5, '#1a1a4a');
            gradient.addColorStop(1, '#0a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
        
        // Draw all game objects
        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw background
            drawBackground();
            
            // Draw enemy bullets
            for (const bullet of enemyBullets) {
                bullet.draw();
            }
            
            // Draw enemies
            for (const enemy of enemies) {
                enemy.draw();
            }
            
            // Draw player bullets
            for (const bullet of playerBullets) {
                bullet.draw();
            }
            
            // Draw player
            if (player) {
                player.draw();
            }
            
            // Draw particles
            for (const particle of particles) {
                particle.draw();
            }
            
            // Draw a subtle vignette effect
            const vignette = ctx.createRadialGradient(
                CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 0,
                CANVAS_WIDTH/2, CANVAS_HEIGHT/2, CANVAS_WIDTH/2
            );
            vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0.2)');
            vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
        
        // Game over logic
        function gameOver() {
            saveHighScore();
            
            if (continues > 0) {
                // Player can continue
                continues--;
                showGameOverScreen();
            } else {
                // Game over completely
                showGameOverScreen();
            }
        }
        
        // Main game loop
        function gameLoop() {
            if (gameState === 'playing') {
                updateGame();
                drawGame();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize the game
        function init() {
            // Load high score
            loadHighScore();
            
            // Set up event listeners for keyboard input
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                
                // Prevent spacebar from scrolling page
                if (e.key === ' ' || e.key === 'Spacebar') {
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Set up button event listeners
            const startButton = document.getElementById('startButton');
            const continueButton = document.getElementById('continueButton');
            const retryButton = document.getElementById('retryButton');
            const giveUpButton = document.getElementById('giveUpButton');
            
            if (startButton) {
                startButton.addEventListener('click', () => {
                    startGame(false);
                });
            }
            
            if (continueButton) {
                continueButton.addEventListener('click', () => {
                    startGame(true);
                });
            }
            
            if (retryButton) {
                retryButton.addEventListener('click', () => {
                    startGame(false);
                });
            }
            
            if (giveUpButton) {
                giveUpButton.addEventListener('click', () => {
                    // Reset score and show title screen
                    score = 0;
                    continues = INITIAL_CONTINUES;
                    showTitleScreen();
                });
            }
            
            // Fix for image error handling - remove src attributes that might cause 404s
            const uiImages = ['titleImage', 'startBtnImage', 'continueBtnImage', 'gameOverImage', 'retryImage', 'giveUpImage'];
            uiImages.forEach(imgId => {
                const imgElement = document.getElementById(imgId);
                if (imgElement) {
                    // Remove any existing src to prevent 404 errors
                    imgElement.removeAttribute('src');
                    imgElement.onerror = function() {
                        console.log(`Failed to load UI image: ${imgId}`);
                        // Hide broken images
                        this.style.display = 'none';
                    };
                }
            });
            
            // Start loading assets
            loadAssets();
            
            // Start game loop
            gameLoop();
            
            // Prevent context menu on right-click
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
